This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-03T23:00:46.681Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    app.config.ts
    google-auth.provider.ts
  modules/
    cache/
      cache.module.ts
      firestore.service.ts
    queue/
      cloud-tasks.service.ts
      queue.module.ts
    storage/
      storage.module.ts
      storage.service.ts
    zpl/
      dto/
        convert-zpl.dto.ts
      zpl.controller.ts
      zpl.module.ts
      zpl.service.ts
  utils/
    utils.module.ts
    zpl-to-pdf.util.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.dockerignore
.env.example
.eslintrc.js
.gitignore
.prettierrc
Dockerfile
gcp-setup.sh
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/config/app.config.ts
================
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  gcpProjectId: process.env.GCP_PROJECT_ID,
  gcpLocation: process.env.GCP_LOCATION || 'us-central1',
  gcpQueueName: process.env.GCP_QUEUE_NAME || 'zpl-conversion-queue',
  gcpServiceAccountEmail: process.env.GCP_SERVICE_ACCOUNT_EMAIL,
  gcpStorageBucket: process.env.GCP_STORAGE_BUCKET || 'zplpdf-app-files',
  serviceUrl: process.env.SERVICE_URL || 'https://zplpdf-app-service-url.a.run.app',
});

================
File: src/config/google-auth.provider.ts
================
import { Provider } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

export const GoogleAuthProvider: Provider = {
  provide: 'GOOGLE_AUTH_OPTIONS',
  useFactory: (configService: ConfigService) => {
    // Obtener las credenciales del archivo .env
    const credentials = configService.get<string>('GOOGLE_CREDENTIALS');
    
    // Si las credenciales existen, convertirlas de string a objeto
    if (credentials) {
      try {
        return { credentials: JSON.parse(credentials) };
      } catch (error) {
        console.error('Error al parsear GOOGLE_CREDENTIALS:', error);
      }
    }
    
    // Si no hay credenciales o hay un error, retornar objeto vacío
    // (se usará la autenticación por defecto de Google Cloud)
    return {};
  },
  inject: [ConfigService],
};

================
File: src/modules/cache/cache.module.ts
================
import { Module } from '@nestjs/common';
import { FirestoreService } from './firestore.service';
import { GoogleAuthProvider } from '../../config/google-auth.provider';

@Module({
  providers: [FirestoreService, GoogleAuthProvider],
  exports: [FirestoreService],
})
export class CacheModule {}

================
File: src/modules/cache/firestore.service.ts
================
import { Injectable, Logger, Inject } from '@nestjs/common';
import { Firestore } from '@google-cloud/firestore';
import { ConfigService } from '@nestjs/config';

interface ConversionStatus {
  status: 'pending' | 'processing' | 'completed' | 'error';
  zplContent?: string;
  labelSize?: string;
  zplHash?: string;
  createdAt: string;
  updatedAt: string;
  errorMessage?: string;
}

@Injectable()
export class FirestoreService {
  private firestore: Firestore;
  private readonly logger = new Logger(FirestoreService.name);
  private readonly collectionName = 'zpl-conversions';

  constructor(
    private configService: ConfigService,
    @Inject('GOOGLE_AUTH_OPTIONS') private googleAuthOptions: any,
  ) {
    this.firestore = new Firestore(this.googleAuthOptions);
  }

  async saveConversionStatus(
    jobId: string,
    status: ConversionStatus,
  ): Promise<void> {
    try {
      await this.firestore
        .collection(this.collectionName)
        .doc(jobId)
        .set(status, { merge: true });
      
      this.logger.log(`Estado de conversión actualizado para jobId: ${jobId}`);
    } catch (error) {
      this.logger.error(`Error al guardar estado: ${error.message}`);
      throw error;
    }
  }

  async getConversionStatus(jobId: string): Promise<ConversionStatus | null> {
    try {
      const doc = await this.firestore
        .collection(this.collectionName)
        .doc(jobId)
        .get();
      
      if (!doc.exists) {
        return null;
      }
      
      return doc.data() as ConversionStatus;
    } catch (error) {
      this.logger.error(`Error al obtener estado: ${error.message}`);
      throw error;
    }
  }

  async updateConversionStatus(
    jobId: string,
    status: Partial<ConversionStatus>,
  ): Promise<void> {
    try {
      await this.firestore
        .collection(this.collectionName)
        .doc(jobId)
        .update({
          ...status,
          updatedAt: new Date().toISOString(),
        });
      
      this.logger.log(`Estado actualizado para jobId: ${jobId}`);
    } catch (error) {
      this.logger.error(`Error al actualizar estado: ${error.message}`);
      throw error;
    }
  }
}

================
File: src/modules/queue/cloud-tasks.service.ts
================
import { Injectable, Logger, Inject } from '@nestjs/common';
import { CloudTasksClient, protos } from '@google-cloud/tasks';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class CloudTasksService {
  private tasksClient: CloudTasksClient;
  private readonly logger = new Logger(CloudTasksService.name);
  private readonly projectId: string;
  private readonly location: string;
  private readonly queueName: string;
  private readonly serviceAccountEmail: string;

  constructor(
    private configService: ConfigService,
    @Inject('GOOGLE_AUTH_OPTIONS') private googleAuthOptions: any,
  ) {
    this.projectId = this.configService.get<string>('GCP_PROJECT_ID');
    this.location = this.configService.get<string>('GCP_LOCATION');
    this.queueName = this.configService.get<string>('GCP_QUEUE_NAME');
    this.serviceAccountEmail = this.configService.get<string>(
      'GCP_SERVICE_ACCOUNT_EMAIL',
    );

    this.tasksClient = new CloudTasksClient(this.googleAuthOptions);
  }

  async enqueueZplConversionTask(
    zplContent: string,
    labelSize: string,
    jobId: string,
    language: string,
  ): Promise<string> {
    const parent = this.tasksClient.queuePath(
      this.projectId,
      this.location,
      this.queueName,
    );

    const task: protos.google.cloud.tasks.v2.ITask = {
      httpRequest: {
        httpMethod: protos.google.cloud.tasks.v2.HttpMethod.POST,
        url: `${this.configService.get<string>('SERVICE_URL')}/api/zpl/process`,
        oidcToken: {
          serviceAccountEmail: this.serviceAccountEmail,
        },
        body: Buffer.from(
          JSON.stringify({
            zplContent,
            labelSize,
            jobId,
            language,
          }),
        ).toString('base64'),
        headers: {
          'Content-Type': 'application/json',
        },
      },
      name: `${parent}/tasks/${jobId}`,
    };

    const [response] = await this.tasksClient.createTask({ parent, task });
    this.logger.log(`Tarea creada: ${response.name}`);
    return response.name;
  }
}

================
File: src/modules/queue/queue.module.ts
================
import { Module } from '@nestjs/common';
import { CloudTasksService } from './cloud-tasks.service';
import { GoogleAuthProvider } from '../../config/google-auth.provider';

@Module({
  providers: [CloudTasksService, GoogleAuthProvider],
  exports: [CloudTasksService],
})
export class QueueModule {}

================
File: src/modules/storage/storage.module.ts
================
import { Module } from '@nestjs/common';
import { StorageService } from './storage.service';
import { GoogleAuthProvider } from '../../config/google-auth.provider';

@Module({
  providers: [StorageService, GoogleAuthProvider],
  exports: [StorageService],
})
export class StorageModule {}

================
File: src/modules/storage/storage.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { Storage } from '@google-cloud/storage';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';
import { Inject } from '@nestjs/common';

@Injectable()
export class StorageService {
  private storage: Storage;
  private readonly logger = new Logger(StorageService.name);
  private readonly bucketName: string;

  constructor(
    private configService: ConfigService,
    @Inject('GOOGLE_AUTH_OPTIONS') private googleAuthOptions: any,
  ) {
    this.bucketName = this.configService.get<string>('GCP_STORAGE_BUCKET');
    this.storage = new Storage(this.googleAuthOptions);
  }

  generateZplHash(zplContent: string, labelSize: string): string {
    return crypto
      .createHash('md5')
      .update(`${zplContent}_${labelSize}`)
      .digest('hex');
  }

  async pdfExists(zplHash: string): Promise<boolean> {
    try {
      const [exists] = await this.storage
        .bucket(this.bucketName)
        .file(`zpl-pdfs/${zplHash}.pdf`)
        .exists();
      
      return exists;
    } catch (error) {
      this.logger.error(`Error al verificar archivo: ${error.message}`);
      return false;
    }
  }

  async savePdf(pdfBuffer: Buffer, zplHash: string): Promise<string> {
    const file = this.storage
      .bucket(this.bucketName)
      .file(`zpl-pdfs/${zplHash}.pdf`);
    
    await file.save(pdfBuffer, {
      metadata: {
        contentType: 'application/pdf',
        cacheControl: 'public, max-age=86400',
      },
    });
    
    // Generar URL firmada válida por 7 días
    const [url] = await file.getSignedUrl({
      action: 'read',
      expires: Date.now() + 7 * 24 * 60 * 60 * 1000,
    });
    
    return url;
  }

  async getSignedUrl(zplHash: string): Promise<string> {
    const file = this.storage
      .bucket(this.bucketName)
      .file(`zpl-pdfs/${zplHash}.pdf`);
    
    const [url] = await file.getSignedUrl({
      action: 'read',
      expires: Date.now() + 7 * 24 * 60 * 60 * 1000,
    });
    
    return url;
  }
}

================
File: src/modules/zpl/dto/convert-zpl.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, IsOptional } from 'class-validator';

export class ConvertZplDto {
  @ApiProperty({
    description: 'Contenido ZPL a convertir a PDF',
    example: '^XA^FO50,50^A0N,50,50^FDHello World^FS^XZ',
  })
  @IsString()
  @IsNotEmpty()
  zplContent: string;

  @ApiProperty({
    description: 'Tamaño de la etiqueta (small: 2x1, large: 4x6 pulgadas)',
    example: 'small',
    enum: ['small', 'large'],
    default: 'small',
  })
  @IsString()
  @IsNotEmpty()
  labelSize: string;

  @ApiProperty({
    description: 'Idioma para los mensajes',
    example: 'es',
    default: 'es',
  })
  @IsString()
  @IsOptional()
  language?: string;
}

================
File: src/modules/zpl/zpl.controller.ts
================
import {
  Controller,
  Post,
  Body,
  Get,
  Param,
  HttpStatus,
  HttpCode,
} from '@nestjs/common';
import { ZplService } from './zpl.service';
import { ConvertZplDto } from './dto/convert-zpl.dto';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';

interface ProcessZplDto {
  zplContent: string;
  labelSize: string;
  jobId: string;
  language: string;
}

@ApiTags('zpl')
@Controller('zpl')
export class ZplController {
  constructor(private readonly zplService: ZplService) {}

  @Post('convert')
  @HttpCode(HttpStatus.ACCEPTED)
  @ApiOperation({ 
    summary: 'Iniciar conversión de ZPL a PDF',
    description: 'Recibe código ZPL y comienza un proceso asíncrono de conversión a PDF',
  })
  @ApiResponse({
    status: HttpStatus.ACCEPTED,
    description: 'Conversión iniciada correctamente',
    schema: {
      properties: {
        jobId: { 
          type: 'string', 
          example: '1234-5678-90ab',
        },
        message: { 
          type: 'string',
          example: 
            'Conversión iniciada. Use el endpoint /status para verificar el estado.',
        },
        statusUrl: { 
          type: 'string',
          example: '/api/zpl/status/1234-5678-90ab',
        },
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Datos de entrada inválidos',
  })
  async convertZpl(@Body() convertZplDto: ConvertZplDto) {
    const jobId = await this.zplService.startZplConversion(
      convertZplDto.zplContent,
      convertZplDto.labelSize,
      convertZplDto.language || 'en', // Soporte multilingüe para mensajes
    );
    
    return {
      jobId,
      message: 'Conversión iniciada. Use el endpoint /status para verificar el estado.',
      statusUrl: `/api/zpl/status/${jobId}`,
    };
  }

  @Post('process')
  @ApiOperation({
    summary: 'Procesar conversión ZPL (uso interno)',
    description: 'Endpoint para uso interno que realiza la conversión efectiva del ZPL a PDF',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Conversión procesada correctamente',
    schema: {
      properties: {
        message: {
          type: 'string',
          example: 'Conversión procesada correctamente',
        },
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Error en el procesamiento',
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Job ID no encontrado',
  })
  async processZpl(@Body() processZplDto: ProcessZplDto) {
    await this.zplService.processZplConversion(
      processZplDto.zplContent,
      processZplDto.labelSize,
      processZplDto.jobId,
    );
    
    return { message: 'Conversión procesada correctamente' };
  }

  @Get('status/:jobId')
  @ApiOperation({
    summary: 'Verificar estado de conversión',
    description: 'Consulta el estado actual de un trabajo de conversión de ZPL a PDF',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Estado del trabajo de conversión',
    schema: {
      properties: {
        status: {
          type: 'string',
          example: 'completed',
          enum: ['pending', 'processing', 'completed', 'failed'],
        },
        progress: {
          type: 'number',
          example: 100,
        },
        message: {
          type: 'string',
          example: 'Conversión completada',
        },
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Job ID no encontrado',
  })
  async checkStatus(@Param('jobId') jobId: string) {
    return await this.zplService.getConversionStatus(jobId);
  }

  @Get('download/:jobId')
  @ApiOperation({
    summary: 'Descargar PDF convertido',
    description: 'Obtiene la URL y nombre del archivo PDF generado para su descarga',
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'URL y nombre del archivo PDF para descargar',
    schema: {
      properties: {
        url: {
          type: 'string',
          example: 'https://storage.example.com/files/label-1234.pdf',
        },
        filename: {
          type: 'string',
          example: 'label-1234.pdf',
        },
      },
    },
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'PDF no encontrado o conversión no completada',
  })
  async downloadPdf(@Param('jobId') jobId: string) {
    const { url, filename } = await this.zplService.getPdfDownloadUrl(jobId);
    return { url, filename };
  }
}

================
File: src/modules/zpl/zpl.module.ts
================
import { Module } from '@nestjs/common';
import { ZplController } from './zpl.controller';
import { ZplService } from './zpl.service';
import { StorageModule } from '../storage/storage.module';
import { QueueModule } from '../queue/queue.module';
import { CacheModule } from '../cache/cache.module';
import { UtilsModule } from '../../utils/utils.module';

@Module({
  imports: [
    StorageModule,
    QueueModule,
    CacheModule,
    UtilsModule,
  ],
  controllers: [ZplController],
  providers: [ZplService],
  exports: [ZplService],
})
export class ZplModule {}

================
File: src/modules/zpl/zpl.service.ts
================
import { Injectable, Logger, HttpException, HttpStatus } from '@nestjs/common';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

import PDFMerger from 'pdf-merger-js';

export enum LabelSize {
  SMALL = '2x1',
  LARGE = '4x6',
}

// Interfaz para el estado de conversión
interface ConversionJob {
  id: string;
  zplContent: string;
  labelSize: LabelSize;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  resultUrl?: string;
  filename?: string;
  error?: string;
  createdAt: Date;
}

interface ZplBlock {
  content: string;
  index: number;
}

// Nuevo tipo para guardar contenido sin ^PQ y la cantidad de copias
interface ParsedZplBlock {
  normalizedContent: string;
  copies: number;
  originalIndex: number;
}

interface ChunkRange {
  start: number;
  end: number;
}

interface UniqueBlocksResult {
  uniqueBlocks: ParsedZplBlock[];
  originalSequence: number[];
}

@Injectable()
export class ZplService {
  private readonly logger = new Logger(ZplService.name);
  private readonly CHUNK_SIZE = 50;
  private readonly jobs = new Map<string, ConversionJob>();
  private readonly storageBasePath = 'https://storage.example.com/files/';


  /**
   * Inicia un proceso de conversión ZPL
   * @param zplContent Contenido ZPL a convertir
   * @param labelSize Tamaño de la etiqueta
   * @param language Idioma para los mensajes
   * @returns ID del trabajo creado
   */
  async startZplConversion(
    zplContent: string,
    labelSize: string,
    language = 'en',
  ): Promise<string> {
    try {
      if (!zplContent) {
        throw new HttpException(
          'El contenido ZPL es obligatorio',
          HttpStatus.BAD_REQUEST,
        );
      }

      const size = labelSize === 'large' ? LabelSize.LARGE : LabelSize.SMALL;
      const jobId = uuidv4();
      
      // Crear y guardar el trabajo
      this.jobs.set(jobId, {
        id: jobId,
        zplContent,
        labelSize: size,
        status: 'pending',
        progress: 0,
        createdAt: new Date(),
      });

      // Encolar el trabajo para procesamiento asíncrono
      // (En un caso real, esto podría ir a un sistema de colas como Bull/Redis)
      setTimeout(() => {
        this.processZplConversion(zplContent, labelSize, jobId);
      }, 100);

      return jobId;
    } catch (error) {
      this.logger.error(`Error al iniciar conversión ZPL: ${error.message}`);
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(
        'Error al iniciar la conversión ZPL',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Procesa la conversión ZPL a PDF (método que sería llamado por un worker)
   * @param zplContent Contenido ZPL a convertir
   * @param labelSize Tamaño de la etiqueta
   * @param jobId ID del trabajo
   */
  async processZplConversion(
    zplContent: string,
    labelSize: string,
    jobId: string,
  ): Promise<void> {
    const job = this.jobs.get(jobId);
    if (!job) {
      this.logger.error(`Trabajo no encontrado: ${jobId}`);
      return;
    }

    try {
      // Actualizar estado a procesando
      job.status = 'processing';
      job.progress = 10;
      this.jobs.set(jobId, job);

      // Convertir ZPL a PDF
      const size = labelSize === 'large' ? LabelSize.LARGE : LabelSize.SMALL;
      const pdfBuffer = await this.convertZplToPdf(zplContent, size);

      // Simular guardado del archivo (en un caso real, se subiría a un servicio de almacenamiento)
      const filename = `label-${jobId}.pdf`;
      const url = `${this.storageBasePath}${filename}`;

      // Actualizar estado a completado
      job.status = 'completed';
      job.progress = 100;
      job.resultUrl = url;
      job.filename = filename;
      this.jobs.set(jobId, job);

      this.logger.log(`Conversión completada para trabajo ${jobId}`);
    } catch (error) {
      this.logger.error(`Error al procesar conversión ZPL: ${error.message}`);
      
      // Actualizar estado a fallido
      job.status = 'failed';
      job.error = error.message;
      this.jobs.set(jobId, job);
    }
  }

  /**
   * Obtiene el estado actual de una conversión
   * @param jobId ID del trabajo
   * @returns Estado del trabajo
   */
  async getConversionStatus(jobId: string) {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new HttpException('Trabajo no encontrado', HttpStatus.NOT_FOUND);
    }

    return {
      status: job.status,
      progress: job.progress,
      message: this.getStatusMessage(job),
    };
  }

  /**
   * Obtiene la URL de descarga del PDF convertido
   * @param jobId ID del trabajo
   * @returns URL y nombre del archivo
   */
  async getPdfDownloadUrl(jobId: string) {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new HttpException('Trabajo no encontrado', HttpStatus.NOT_FOUND);
    }

    if (job.status !== 'completed') {
      throw new HttpException(
        'La conversión no está completa', 
        HttpStatus.BAD_REQUEST,
      );
    }

    if (!job.resultUrl || !job.filename) {
      throw new HttpException(
        'No se encuentra el archivo de resultado', 
        HttpStatus.NOT_FOUND,
      );
    }

    return {
      url: job.resultUrl,
      filename: job.filename,
    };
  }

  /**
   * Obtiene un mensaje de estado según el estado del trabajo
   * @param job Trabajo de conversión
   * @returns Mensaje descriptivo
   */
  private getStatusMessage(job: ConversionJob): string {
    switch (job.status) {
      case 'pending':
        return 'Conversión en cola';
      case 'processing':
        return `Procesando (${job.progress}%)`;
      case 'completed':
        return 'Conversión completada';
      case 'failed':
        return `Error: ${job.error || 'Desconocido'}`;
      default:
        return 'Estado desconocido';
    }
  }

  /**
   * Convierte ZPL a PDF
   * @param zplRaw Contenido ZPL
   * @param labelSize Tamaño de etiqueta
   * @returns Buffer del PDF
   */
  private async convertZplToPdf(zplRaw: string, labelSize: LabelSize): Promise<Buffer> {
    try {
      if (!zplRaw) {
        throw new HttpException('ZPL content is required', HttpStatus.BAD_REQUEST);
      }
      // 1. Extraer y normalizar bloques ZPL
      const parsedBlocks = this.splitAndExtractCopies(zplRaw);
      if (parsedBlocks.length === 0) {
        throw new HttpException(
          'No valid ZPL blocks found',
          HttpStatus.BAD_REQUEST
        );
      }

      // 2. Identificar bloques únicos y su secuencia original
      const { uniqueBlocks, originalSequence } = this.identifyUniqueBlocks(parsedBlocks);

      // 3. Dividir bloques únicos en chunks de 50 (límite de Labelary)
      const chunkRanges = this.calculateChunkRanges(uniqueBlocks.length);

      // 4. Convertir cada chunk de bloques únicos a PDF
      const chunkPdfs: Buffer[] = [];
      for (const range of chunkRanges) {
        const chunkBlocks = uniqueBlocks.slice(range.start, range.end);

        const formattedBlocks = chunkBlocks.map(({ normalizedContent }) => {
          let content = normalizedContent;
          if (!content.startsWith('^XA')) content = '^XA' + content;
          if (!content.endsWith('^XZ')) content += '^XZ';
          return content;
        });

        const chunkZpl = formattedBlocks.join('\n');
        const pdfBuffer = await this.callLabelary(chunkZpl, labelSize);
        chunkPdfs.push(pdfBuffer);
      }

      // 5. Reconstruir el PDF final (replicando cada bloque según copies)
      return this.reconstructFinalPdf(chunkPdfs, originalSequence);
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(
        'Error converting ZPL to PDF',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Divide ZPL en bloques, extrae copias ^PQ y elimina ^PQ del contenido
   * @param zpl Contenido ZPL
   * @returns Bloques ZPL procesados
   */
  private splitAndExtractCopies(zpl: string): ParsedZplBlock[] {
    const blockMatches = zpl.match(/\^XA.*?\^XZ/gs) || [];
    let parsed: ParsedZplBlock[] = [];
    blockMatches.forEach((rawBlock, i) => {
      const normalized = this.normalizeZplBlock(rawBlock);
      const pqMatch = normalized.match(/\^PQ(\d+)/i);
      let copies = 1;
      if (pqMatch && pqMatch[1]) {
        copies = parseInt(pqMatch[1], 10) || 1;
      }
      const cleaned = normalized.replace(/\^PQ[^\^]+/i, '');

      parsed.push({
        normalizedContent: cleaned.trim(),
        copies,
        originalIndex: i,
      });
    });
    return parsed;
  }

  /**
   * Deduplica bloques ignorando 'copies' para la llamada a la API,
   * pero almacena las copias reales en originalSequence
   */
  private identifyUniqueBlocks(
    blocks: ParsedZplBlock[]
  ): UniqueBlocksResult {
    const uniqueBlocks: ParsedZplBlock[] = [];
    const blockMap = new Map<string, number>();
    const originalSequence: number[] = [];

    for (const pb of blocks) {
      const contentKey = pb.normalizedContent;
      let idx = blockMap.get(contentKey);
      if (idx === undefined) {
        idx = uniqueBlocks.length;
        blockMap.set(contentKey, idx);
        uniqueBlocks.push({
          normalizedContent: contentKey,
          copies: pb.copies,
          originalIndex: pb.originalIndex,
        });
      }
      for (let c = 0; c < pb.copies; c++) {
        originalSequence.push(idx);
      }
    }

    return {
      uniqueBlocks,
      originalSequence,
    };
  }

  /**
   * Calcula rangos de chunks para procesar bloques en lotes
   * @param totalBlocks Número total de bloques a procesar
   * @returns Array de rangos de chunks
   */
  private calculateChunkRanges(totalBlocks: number): ChunkRange[] {
    const ranges: ChunkRange[] = [];
    for (let i = 0; i < totalBlocks; i += this.CHUNK_SIZE) {
      ranges.push({
        start: i,
        end: Math.min(i + this.CHUNK_SIZE, totalBlocks),
      });
    }
    return ranges;
  }

  /**
   * Normaliza un bloque ZPL eliminando espacios innecesarios y estandarizando el formato
   * @param block Bloque ZPL a normalizar
   * @returns Bloque ZPL normalizado
   */
  private normalizeZplBlock(block: string): string {
    let normalized = block
      .replace(/[\r\n]+/g, '')
      .replace(/\s+/g, ' ')
      .trim();

    if (!normalized.startsWith('^XA')) {
      normalized = '^XA' + normalized;
    }
    if (!normalized.endsWith('^XZ')) {
      normalized = normalized + '^XZ';
    }

    return normalized;
  }

  /**
   * Llama a la API de Labelary para convertir ZPL a PDF
   * @param zpl Cadena ZPL a convertir
   * @param labelSize Tamaño de la etiqueta
   * @returns Buffer del PDF
   */
  private async callLabelary(zplBatch: string, labelSize: LabelSize): Promise<Buffer> {
    try {
      const url = `http://api.labelary.com/v1/printers/8dpmm/labels/${labelSize}`;

      const labelCount = (zplBatch.match(/\^XA/g) || []).length;

      if (labelCount > this.CHUNK_SIZE) {
        throw new HttpException(
          `El número de etiquetas (${labelCount}) excede el límite permitido (${this.CHUNK_SIZE} etiquetas por solicitud)`,
          HttpStatus.PAYLOAD_TOO_LARGE
        );
      }

      const response = await axios.post(url, zplBatch, {
        headers: {
          Accept: 'application/pdf',
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        responseType: 'arraybuffer',
      });

      if (response.status !== 200) {
        throw new Error(`Labelary API error: ${response.status}`);
      }

      return Buffer.from(response.data);
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      if (error.response?.status === 413) {
        throw new HttpException(
          'El número de etiquetas excede el límite permitido (50 etiquetas por solicitud)',
          HttpStatus.PAYLOAD_TOO_LARGE
        );
      }
      throw new HttpException(
        'Error in Labelary API conversion',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Reconstruye el PDF final usando la secuencia original
   * @param chunkPdfs Array de buffers PDF de chunks
   * @param originalSequence Array de índices que representan el orden original
   * @returns Buffer del PDF final fusionado
   */
  private async reconstructFinalPdf(
    chunkPdfs: Buffer[],
    originalSequence: number[],
  ): Promise<Buffer> {
    try {
      const merger = new PDFMerger();
      let lastChunkUsed = -1;
      let lastDocPages = 0;

      for (const blockIdx of originalSequence) {
        const chunkNumber = Math.floor(blockIdx / this.CHUNK_SIZE);
        const pageInChunk = (blockIdx % this.CHUNK_SIZE) + 1;

        if (chunkNumber !== lastChunkUsed) {
          lastChunkUsed = chunkNumber;
          const chunkPdfData = chunkPdfs[chunkNumber];
          const tempMerger = new PDFMerger();
          await tempMerger.add(chunkPdfData);
          lastDocPages = (await tempMerger.saveAsBuffer()).length;
        }

        await merger.add(chunkPdfs[chunkNumber], pageInChunk.toString());
      }

      return await merger.saveAsBuffer();
    } catch (error) {
      this.logger.error('Error al fusionar PDFs:', error);
      throw new HttpException(
        'Error merging PDF files',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}

================
File: src/utils/utils.module.ts
================
import { Module } from '@nestjs/common';
import { ZplToPdfConverter } from './zpl-to-pdf.util';

@Module({
  providers: [ZplToPdfConverter],
  exports: [ZplToPdfConverter],
})
export class UtilsModule {}

================
File: src/utils/zpl-to-pdf.util.ts
================
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class ZplToPdfConverter {
  private readonly logger = new Logger(ZplToPdfConverter.name);

  /**
   * Convierte un contenido ZPL a un buffer PDF
   * 
   * Este es un método de ejemplo que en una implementación real
   * utilizaría una biblioteca como Labelary API, librería ZPL, etc.
   */
  async convert(zplContent: string, labelSize: string): Promise<Buffer> {
    this.logger.log(`Convirtiendo ZPL a PDF. Tamaño: ${labelSize}`);
    
    // Aquí iría la lógica real de conversión ZPL a PDF
    // En este ejemplo, simulamos la conversión con un PDF básico
    
    // Esto sería reemplazado por tu código real de conversión
    const samplePdf = Buffer.from(
      '%PDF-1.5\n1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 300 200]/Parent 2 0 R/Resources<<>>/Contents 4 0 R>>endobj 4 0 obj<</Length 51>>stream\nBT\n/F1 12 Tf\n100 100 Td\n(ZPL convertido a PDF) Tj\nET\nendstream\nendobj\nxref\n0 5\n0000000000 65535 f\n0000000018 00000 n\n0000000063 00000 n\n0000000114 00000 n\n0000000223 00000 n\ntrailer<</Size 5/Root 1 0 R>>\nstartxref\n324\n%%EOF',
      'ascii'
    );
    
    // Simulamos un tiempo de procesamiento
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    return samplePdf;
  }
}

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ZplModule } from './modules/zpl/zpl.module';
import appConfig from './config/app.config';
import { GoogleAuthProvider } from './config/google-auth.provider';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [appConfig],
    }),
    ZplModule,
  ],
  controllers: [AppController],
  providers: [AppService, GoogleAuthProvider],
  exports: [GoogleAuthProvider],
})
export class AppModule {}

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Configurar el prefijo global de la API
  app.setGlobalPrefix('api');
  
  // Habilitar validación de DTO
  app.useGlobalPipes(new ValidationPipe({ transform: true }));
  
  // Configurar Swagger
  const config = new DocumentBuilder()
    .setTitle('ZPLPDF API')
    .setDescription('API para conversión de ZPL a PDF')
    .setVersion('1.0')
    .addTag('zpl')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);
  
  // Iniciar el servidor
  await app.listen(process.env.PORT || 3000);
  console.log(`Aplicación corriendo en: ${await app.getUrl()}`);
}
bootstrap();

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: .dockerignore
================
node_modules
npm-debug.log
dist
.git
.env
.env.*
.vscode
.idea
.DS_Store
*.pem
*credentials*
*key*

================
File: .env.example
================
# Puerto del servidor
PORT=3000

# Configuración Google Cloud Platform
GCP_PROJECT_ID=zplpdf-app
GCP_LOCATION=us-central1
GCP_QUEUE_NAME=zpl-conversion-queue
GCP_SERVICE_ACCOUNT_EMAIL=zplpdf-service@zplpdf-app.iam.gserviceaccount.com
GCP_STORAGE_BUCKET=zplpdf-app-files

# URL del servicio
SERVICE_URL=https://zplpdf-app-service-url.a.run.app

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: Dockerfile
================
FROM node:18-alpine As development

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm ci --legacy-peer-deps

COPY . .

RUN npm run build

FROM node:18-alpine As production

ARG NODE_ENV=production
ENV NODE_ENV=${NODE_ENV}

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm ci --only=production --legacy-peer-deps

COPY --from=development /usr/src/app/dist ./dist

EXPOSE 8080

CMD ["node", "dist/main"]

================
File: gcp-setup.sh
================
#!/bin/bash

# Script para configurar Google Cloud para el despliegue

# Verificar si gcloud está instalado
if ! command -v gcloud &> /dev/null; then
    echo "Error: gcloud CLI no está instalado. Por favor, instálalo primero."
    exit 1
fi

# Autenticar con Google Cloud
echo "Autenticando con Google Cloud..."
gcloud auth login

# Configurar el proyecto
echo "Configurando el proyecto..."
gcloud config set project intranet-guatever

# Habilitar los servicios necesarios
echo "Habilitando servicios necesarios..."
gcloud services enable cloudbuild.googleapis.com
gcloud services enable run.googleapis.com
gcloud services enable firestore.googleapis.com
gcloud services enable storage.googleapis.com
gcloud services enable cloudtasks.googleapis.com

# Crear un bucket de Storage si no existe
echo "Verificando bucket de Storage..."
if ! gsutil ls gs://intranet-guatever-files &> /dev/null; then
    echo "Creando bucket de Storage..."
    gsutil mb -l us-central1 gs://intranet-guatever-files
    gsutil iam ch allUsers:objectViewer gs://intranet-guatever-files
fi

# Crear una cola de Cloud Tasks si no existe
echo "Configurando Cloud Tasks..."
gcloud tasks queues create zpl-conversion-queue \
    --location=us-central1 \
    2>/dev/null || echo "La cola ya existe o hubo un error al crearla"

echo "Configuración completada. Ya puedes desplegar la aplicación con:"
echo "npm run deploy:build"
echo "npm run deploy:run"

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: package.json
================
{
  "name": "zplpdf",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
 "type": "module",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "deploy:build": "gcloud builds submit --tag gcr.io/intranet-guatever/zplpdf-service",
    "deploy:run": "gcloud run deploy zplpdf-service --image gcr.io/intranet-guatever/zplpdf-service --platform managed --region us-central1 --allow-unauthenticated"
  },
  "dependencies": {
    "@google-cloud/firestore": "^7.11.0",
    "@google-cloud/storage": "^7.15.2",
    "@google-cloud/tasks": "^5.5.2",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.1",
    "@nestjs/core": "^10.0.0",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "^11.0.6",
    "axios": "^1.8.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "pdf-merger-js": "^5.1.2",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: README.md
================
# ZPLPDF Application

Aplicación para convertir archivos ZPL a PDF utilizando Google Cloud Run.

## Estructura del Proyecto

```
src/
├── main.ts                     # Punto de entrada
├── app.module.ts               # Módulo principal
├── modules/
│   ├── zpl/                    # Módulo de conversión ZPL
│   │   ├── zpl.controller.ts   # Endpoints de la API
│   │   ├── zpl.service.ts      # Lógica de conversión
│   │   ├── dto/                # Data transfer objects
│   │   └── interfaces/         # Interfaces y tipos
│   ├── queue/                  # Módulo de gestión de colas
│   │   ├── cloud-tasks.service.ts
│   ├── storage/                # Módulo de almacenamiento
│   │   ├── storage.service.ts  # Gestión de archivos en Cloud Storage
│   ├── cache/                  # Módulo de caché
│   │   ├── firestore.service.ts # Manejo de caché en Firestore
│   └── health/                 # Endpoints de salud
├── config/                     # Configuración global
└── utils/                      # Utilidades
```

## Requisitos

- Node.js (v14 o superior)
- npm o yarn
- Cuenta de Google Cloud Platform
- gcloud CLI instalado y configurado

## Configuración del Proyecto en Google Cloud

```bash
# Crear proyecto en Google Cloud
gcloud projects create zplpdf-app --name="ZPLPDF Application"

# Habilitar servicios necesarios
gcloud services enable cloudbuild.googleapis.com
gcloud services enable run.googleapis.com
gcloud services enable firestore.googleapis.com
gcloud services enable storage.googleapis.com
gcloud services enable cloudtasks.googleapis.com
```

## Instalación y Desarrollo Local

1. Clonar el repositorio
2. Instalar dependencias:

```bash
npm install
```

3. Copiar el archivo `.env.example` a `.env` y configurar las variables de entorno:

```bash
cp .env.example .env
```

4. Iniciar el servidor en modo desarrollo:

```bash
npm run start:dev
```

## Despliegue en Google Cloud Run

```bash
# Construir la imagen
gcloud builds submit --tag gcr.io/zplpdf-app/zplpdf-service

# Desplegar el servicio
gcloud run deploy zplpdf-service \
  --image gcr.io/zplpdf-app/zplpdf-service \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --update-env-vars GCP_PROJECT_ID=zplpdf-app,GCP_LOCATION=us-central1
```

## Endpoints de la API

- `POST /api/zpl/convert`: Iniciar conversión de ZPL a PDF
- `GET /api/zpl/status/:jobId`: Verificar estado de conversión
- `GET /api/zpl/download/:jobId`: Descargar PDF convertido
- `GET /api/docs`: Documentación Swagger de la API

## Licencia

MIT

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "ESNext",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "moduleResolution": "node"
  }
}
